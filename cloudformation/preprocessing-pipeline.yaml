# A template that creates the processing pipeline for biometric data
# Version: da39a3ee5e6b4b0d3255bfef95601890afd80709
#
# Copyright 2017 Melon Software Ltd (UK), all rights reserved
#
AWSTemplateFormatVersion: "2010-09-09"
Description: "Creates a pre-processing pipeline"

Parameters:

    Environment:
        Type: "String"
        Description: "The name of the Environment"

    BatchJobVersion:
        Type: "String"
        Description: "The version of the batch jobs to run"

Mappings:
    TemplateVersion:
        Self: { Commit: "da39a3ee5e6b4b0d3255bfef95601890afd80709" }
    BatchJobResources:
        downloadandchunk:       { Memory: 2048, Vcpus: 2 }
        transformandplacement:  { Memory: 4096, Vcpus: 2 }
        sessionprocess2:        { Memory: 1024, Vcpus: 2 }
        scoring:                { Memory: 7650, Vcpus: 2 }
        aggregatesession:       { Memory: 7650, Vcpus: 2 }
        aggregateblocks:        { Memory: 7650, Vcpus: 2 }
        aggregatetwomin:        { Memory: 2048, Vcpus: 2 }
        aggregatedateuser:      { Memory: 512,  Vcpus: 1 }
        aggregateteam:          { Memory: 512,  Vcpus: 1 }
        aggregatetraininggroup: { Memory: 512,  Vcpus: 1 }
        aggregateprogcomp:      { Memory: 7650, Vcpus: 2 }
        aggregateprogcompdate:  { Memory: 512,  Vcpus: 1 }
        cleanup:                { Memory: 256,  Vcpus: 1 }

Metadata:
    "AWS::CloudFormation::Interface":
        ParameterLabels:
            Environment: { default: "Environment" }
            BatchJobVersion: { default: "Application Code version" }

Resources:

    ##########################################################################################################
    ##  IAM
    ##########################################################################################################

    LambdaExecutionRole:
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: "Allow"
                    Principal: { Service: [ "lambda.amazonaws.com" ] }
                    Action: "sts:AssumeRole"
            ManagedPolicyArns:
              - "arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole"
            Policies:
              - PolicyName: "default"
                PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Action:
                          - "logs:CreateLogGroup"
                          - "logs:CreateLogStream"
                          - "logs:PutLogEvents"
                          - "cloudwatch:PutMetricData"
                        Effect: "Allow"
                        Resource: "*"

                      - Action:
                          - "sns:Publish"
                          - "lambda:InvokeFunction"
                          - "s3:ListBucket"
                        Effect: "Allow"
                        Resource: "*"

                      - Action:
                          - "ssm:DescribeParameters"
                          - "ssm:GetParameters"
                          - "kms:Decrypt"
                        Effect: "Allow"
                        Resource:
                          - "*" # TODO this should be segregated by environment somehow

                      - Action:
                          - "dynamodb:PutItem"
                          - "dynamodb:Query"
                          - "dynamodb:UpdateItem"
                        Effect: "Allow"
                        Resource: { "Fn::Sub": "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/preprocessing-${Environment}-ingest-*" }
            RoleName: { "Fn::Sub": "preprocessing-${Environment}-lambda-${AWS::Region}" }

    BatchExecutionRole:
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: "Allow"
                    Principal: { Service: [ "ecs-tasks.amazonaws.com" ] }
                    Action: "sts:AssumeRole"
            Policies:
              - PolicyName: "default"
                PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Action:
                          - "s3:GetObject"
                          - "s3:ListBucket"
                        Effect: "Allow"
                        Resource:
                          - "arn:aws:s3:::biometrix-globalmodels"
                          - "arn:aws:s3:::biometrix-globalmodels/*"
                          - { "Fn::Sub": "arn:aws:s3:::biometrix-preprocessing-${Environment}-${AWS::Region}" }
                          - { "Fn::Sub": "arn:aws:s3:::biometrix-preprocessing-${Environment}-${AWS::Region}/*" }

                      - Action:
                          - "s3:GetObject"
                          - "s3:ListBucket"
                          - "s3:PutObject"
                        Effect: "Allow"
                        Resource:
                          - "arn:aws:s3:::biometrix-decode"
                          - "arn:aws:s3:::biometrix-decode/*"

                      - Action:
                          - "states:SendTaskFailure"
                          - "states:SendTaskHeartbeat"
                          - "states:SendTaskSuccess"
                        Effect: "Allow"
                        Resource: { Ref: "StepFunctionsActivity" }

                      - Action:
                          - "ssm:DescribeParameters"
                          - "ssm:GetParameters"
                          - "kms:Decrypt"
                        Effect: "Allow"
                        Resource: "*" # TODO this should be segregated by environment somehow

                      - Action:
                          - "cloudwatch:PutMetricData"
                        Effect: "Allow"
                        Resource: "*"

                      - Action:
                          - "dynamodb:PutItem"
                          - "dynamodb:Query"
                          - "dynamodb:UpdateItem"
                        Effect: "Allow"
                        Resource: { "Fn::Sub": "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/preprocessing-${Environment}-ingest-*" }

            RoleName: { "Fn::Sub": "preprocessing-${Environment}-execute-${AWS::Region}" }

    StreamLambdaRole:
        Type: "AWS::IAM::Role"
        Properties:
            AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: "Allow"
                    Principal: { Service: [ "lambda.amazonaws.com" ] }
                    Action: "sts:AssumeRole"
            ManagedPolicyArns:
              - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
            Policies:
              - PolicyName: "default"
                PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Action:
                          - "states:GetActivityTask"
                        Effect: "Allow"
                        Resource: { Ref: "StepFunctionsActivity" }

                      - Action:
                          - "batch:DescribeJobDefinitions"
                          - "batch:DescribeJobQueues"
                          - "batch:SubmitJob"
                          - "states:SendTaskSuccess"
                          - "states:SendTaskFailure"
                        Effect: "Allow"
                        Resource: "*" # Batch doesn't support resource-level permissions

                      - Action:
                          - "events:PutEvents"
                          - "cloudwatch:PutMetricData"
                          - "logs:CreateLogStream"
                          - "logs:PutLogEvents"
                          - "logs:DescribeLogStreams"
                        Effect: "Allow"
                        Resource: "*"
            RoleName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-stream" }

    ##########################################################################################################
    ##  BATCH
    ##########################################################################################################

    BatchJobImage:
        Type: "Custom::CodeBuildEcrImage"
        Properties:
            ServiceToken: { "Fn::Sub": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:preprocessing-infrastructure-batchjob-trigger" }
            EcrImageTag: { Ref: "BatchJobVersion" }

    BatchJobDefinition:
        Type: "AWS::Batch::JobDefinition"
        Properties:
            Type: "container"
            Parameters: { "Meta": "{}", "Input": "{}" }
            ContainerProperties:
                Command: [ "Ref::Job", "Ref::Input", "Ref::Meta" ]
                Memory: 512
                Privileged: true
                JobRoleArn: { "Fn::Sub": "arn:aws:iam::${AWS::AccountId}:role/preprocessing-${Environment}-execute-${AWS::Region}" }
                ReadonlyRootFilesystem: false
                Vcpus: 2
                Image: { Ref: "BatchJobImage" }
            JobDefinitionName: { "Fn::Sub": "preprocessing-${Environment}-batchjob" }
            RetryStrategy:
                Attempts: 1

    ##########################################################################################################
    ##  LAMBDA
    ##########################################################################################################

    LambdaUnpackParallelResults:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: |
                    def handler(input, _):
                        for branch in input['_Unpack']:
                            for k, v in branch.items():
                                input[k] = v
                        del input['_Unpack']
                        return input
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-unpackparallelresults" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-unpackparallelresults" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaUpdateStatus:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: |
                    import boto3, os, datetime
                    from boto3.dynamodb.conditions import Attr
                    ddb_session_events_table = boto3.resource('dynamodb').Table(os.environ['DYNAMODB_SESSION_EVENTS_TABLE_NAME'])

                    def handler(data, _):
                        session_event_updates = DynamodbUpdate()
                        session_event_updates.set("updated_date", datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"))
                        session_event_updates.set("session_status", data['SessionStatus'])

                        ddb_session_events_table.update_item(
                            Key={'id': data['SessionId']},
                            ConditionExpression=Attr('id').exists(),
                            UpdateExpression=session_event_updates.update_expression,
                            ExpressionAttributeValues=session_event_updates.parameters,
                        )

                    class DynamodbUpdate:
                        def __init__(self):
                            self._add = []
                            self._set = []
                            self._parameters = {}

                        def set(self, field, value):
                            self._set.append("{field} = :{field}".format(field=field))
                            self._parameters[':' + field] = value

                        def add(self, field, value):
                            self._add.append("{field} :{field}".format(field=field))
                            self._parameters[':' + field] = value

                        @property
                        def update_expression(self):
                            return 'SET {} '.format(', '.join(self._set)) + (
                                'ADD {}'.format(', '.join(self._add)) if len(self._add) else '')

                        @property
                        def parameters(self):
                            return self._parameters
            Environment:
                Variables:
                    DYNAMODB_SESSION_EVENTS_TABLE_NAME: { "Fn::Sub": "preprocessing-${Environment}-ingest-sessions" }
                    ENVIRONMENT: { Ref: "Environment" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-updatestatus" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-updatestatus" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareDownloadAndChunk:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "downloadandchunk",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": event['SourceEvent']
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "downloadandchunk", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "downloadandchunk", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-downloadandchunk" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-downloadandchunk" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaReadData:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, json, os
                    from boto3.dynamodb.conditions import Key
                    dynamodb_resource = boto3.resource('dynamodb').Table('preprocessing-{}-ingest-sessions'.format(os.environ['ENVIRONMENT']))

                    def handler(event, context):
                        session_id = event['SourceEvent']['SessionId']
                        ret = dynamodb_resource.query(Select='ALL_ATTRIBUTES', KeyConditionExpression=Key('id').eq(session_id))
                        session = ret['Items'][0]
                        print(session)
                        return {
                            "SessionId": session_id,
                            "Version": session['version'],
                            "EventDate": session.get('event_date', '').split('T')[0],
                            "TeamId": session.get('team_id', None),
                            "TrainingGroupIds": list(session.get('training_group_ids', [])),
                            "UserId": session.get('user_id', None),
                            "UserMassKg": session.get('user_mass', None) or 72.5, # kilograms
                        }

            Environment:
                Variables:
                    ENVIRONMENT: { Ref: "Environment" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-readdata" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-readdata" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareTransformAndPlacement:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "transformandplacement",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": event["ReadDatabase"],
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "transformandplacement", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "transformandplacement", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-transformandplacement" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-transformandplacement" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareSessionProcess2:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "sessionprocess2",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": event['TransformAndPlacement']['Output']['FileCount'],
                            "Input": {**event["ReadDatabase"], **event['TransformAndPlacement']['Output']},
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "sessionprocess2", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "sessionprocess2", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-sessionprocess2" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-sessionprocess2" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareScoring:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "scoring",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Filenames": event['TransformAndPlacement']['Output']['Filenames'],
                                   "Sensors": event['TransformAndPlacement']['Output']['Sensors'],
                                }
                            }
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "scoring", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "scoring", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-scoring" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-scoring" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateSession:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregatesession",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Sensors": event['TransformAndPlacement']['Output']['Sensors']}
                            }
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregatesession", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregatesession", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatesession" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatesession" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateBlocks:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregateblocks",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Sensors": event['TransformAndPlacement']['Output']['Sensors']}
                            },
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregateblocks", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregateblocks", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateblocks" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateblocks" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateTwomin:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregatetwomin",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": event['Scoring']['Output']['FileCount'],
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Sensors": event['TransformAndPlacement']['Output']['Sensors']}
                            }
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregatetwomin", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregatetwomin", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatetwomin" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatetwomin" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateDateUser:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregatedateuser",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": event["ReadDatabase"],
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregatedateuser", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregatedateuser", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatedateuser" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatedateuser" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateTeam:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregateteam",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": event["ReadDatabase"],
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregateteam", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregateteam", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateteam" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateteam" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateTrainingGroup:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        training_group_ids = event["ReadDatabase"]["TrainingGroupIds"] or {}
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregatetraininggroup",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": event["ReadDatabase"],
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregatetraininggroup", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregatetraininggroup", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatetraininggroup" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregatetraininggroup" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateProgComp:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregateprogcomp",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Sensors": event['TransformAndPlacement']['Output']['Sensors']}
                            },
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregateprogcomp", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregateprogcomp", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateprogcomp" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateprogcomp" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareAggregateProgCompDate:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "aggregateprogcompdate",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": {
                                **event["ReadDatabase"],
                                **{"Sensors": event['TransformAndPlacement']['Output']['Sensors']}
                            },
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "aggregateprogcompdate", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "aggregateprogcompdate", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateprogcompdate" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-aggregateprogcompdate" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaNotifyFailure:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    def handler(event, context):
                        import boto3, os
                        sns_client = boto3.client('sns')
                        response = sns_client.publish(
                            TopicArn=os.environ['SNS_TOPIC'],
                            Message=event['ReadDatabase']['SessionId'],
                        )
            Environment:
                Variables:
                    SNS_TOPIC: { Ref: "SnsFailureTopic" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-notifyfailure" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-notifyfailure" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    LambdaPrepareCleanup:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import os
                    def handler(event, context):
                        return {
                            "Meta": {
                                "ExecutionName": event['Meta']['ExecutionName'],
                            },
                            "Resource": {
                                "BatchJob": "cleanup",
                                "Memory": int(os.environ['BATCH_JOB_MEMORY']),
                                "Vcpus": int(os.environ['BATCH_JOB_VCPUS']),
                            },
                            "ArraySize": 1,
                            "Input": event["ReadDatabase"]
                        }
            Environment:
                Variables:
                    BATCH_JOB_MEMORY: { "Fn::FindInMap": [ "BatchJobResources", "cleanup", "Memory" ] }
                    BATCH_JOB_VCPUS: { "Fn::FindInMap": [ "BatchJobResources", "cleanup", "Vcpus" ] }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "30"
            Role: { "Fn::GetAtt" : [ "LambdaExecutionRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-prepare-cleanup" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-cleanup" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    ##########################################################################################################
    ##  SNS
    ##########################################################################################################

    SnsFailureTopic:
        Type: "AWS::SNS::Topic"
        Properties:
            DisplayName: "Biometrix preprocessing failure notification"
            TopicName: { "Fn::Sub": "preprocessing-${Environment}-failure" }

    SnsDataQualityTopic:
        Type: "AWS::SNS::Topic"
        Properties:
            DisplayName: "PreProcessing data quality issue notifications"
            TopicName: { "Fn::Sub": "preprocessing-${Environment}-dataquality" }

    SnsDataQualitySubscriptionDipesh:
        Type: "AWS::SNS::Subscription"
        Properties:
            Endpoint: { "Fn::Sub": "dipesh+dataquality-${Environment}@fathomai.com" }
            Protocol: "email"
            TopicArn: { Ref: "SnsDataQualityTopic" }

    SnsDataQualitySubscriptionGabby:
        Type: "AWS::SNS::Subscription"
        Properties:
            Endpoint: { "Fn::Sub": "gabby+dataquality-${Environment}@fathomai.com" }
            Protocol: "email"
            TopicArn: { Ref: "SnsDataQualityTopic" }

    ##########################################################################################################
    ##  STEP FUNCTIONS
    ##########################################################################################################

    StepFunctionsActivity:
        Type: "AWS::StepFunctions::Activity"
        Properties:
            Name: { "Fn::Sub": "preprocessing-${Environment}" }

    SfnToCweLambda:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, botocore.config, datetime, json, os, time

                    sfn_client = boto3.client('stepfunctions', config=botocore.config.Config(retries={'max_attempts': 0}))
                    cwe_client = boto3.client('events')


                    def handler(_, context):

                        payload = None
                        while context.get_remaining_time_in_millis() / 1000 > 65:
                            try:
                                print('Polling for task token, {}ms remaining'.format(context.get_remaining_time_in_millis()))
                                payload = sfn_client.get_activity_task(
                                    activityArn=os.environ['STEP_FUNCTIONS_ACTIVITY_ARN'],
                                    workerName=context.log_stream_name[-80:]
                                )
                                print('Got response, {}ms remaining'.format(context.get_remaining_time_in_millis()))
                                process_payload(payload)
                                payload = None
                            except Exception as e:
                                print(str(e))
                                continue

                        # Process any last payload
                        if payload is not None:
                            process_payload(payload)


                    def process_payload(payload):
                        print(json.dumps(payload))
                        task_token = payload.get('taskToken', '')
                        task_event = json.loads(payload.get('input','""'))

                        if task_token != '':
                            print('Putting SFN Activity as a CloudWatch Event')
                            payload = json.dumps({'task_event': task_event, 'task_token': task_token})
                            print(payload)
                            response = cwe_client.put_events(
                                Entries=[
                                    {
                                        'Time': datetime.datetime.now(),
                                        'Source': 'customaws.stepfunctions',
                                        'Resources': [
                                            os.environ['STEP_FUNCTIONS_ACTIVITY_ARN'],
                                            os.environ['STEP_FUNCTIONS_STATE_MACHINE_ARN'],
                                        ],
                                        'DetailType': 'Step Functions Activity Scheuduled',
                                        'Detail': payload
                                    },
                                ]
                            )
                            print(json.dumps({'event_id': response['Entries'][0]['EventId']}))
                        else:
                            # There are no tasks waiting to be scheduled.
                            print('No task waiting, sleeping')
                            time.sleep(2)

            Environment:
                Variables:
                    STEP_FUNCTIONS_ACTIVITY_ARN: { Ref: "StepFunctionsActivity" }
                    STEP_FUNCTIONS_STATE_MACHINE_ARN: { Ref: "StateMachine" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "300"
            Role: { "Fn::GetAtt" : [ "StreamLambdaRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-sfntocwe" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-sfntocwe" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    SfnToCweScheduledRule:
        Type: "AWS::Events::Rule"
        Properties:
            Description: "ScheduledRule"
            ScheduleExpression: "rate(4 minutes)"
            State: "ENABLED"
            Targets:
              - Arn: { "Fn::GetAtt": [ "SfnToCweLambda", "Arn" ] }
                Id: "TargetFunctionV1"

    SfnToCweInvokePermission:
        Type: "AWS::Lambda::Permission"
        Properties:
            FunctionName: { Ref: "SfnToCweLambda" }
            Action: "lambda:InvokeFunction"
            Principal: "events.amazonaws.com"
            SourceArn: { "Fn::GetAtt": [ "SfnToCweScheduledRule", "Arn" ] }

    CweToBatchLambda:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, json, os, time

                    batch_client = boto3.client('batch')


                    def handler(event, _):
                        print(json.dumps(event))
                        task_event = event['detail']['task_event']
                        task_token = event['detail']['task_token']

                        meta = task_event.get('Meta', None)
                        input_data = task_event.get('Input', None)
                        resource = task_event.get('Resource', None)
                        array_size = task_event.get('ArraySize', None)

                        meta['TaskToken'] = task_token
                        meta['Profiling'] = {'ScheduleTime': time.time()}

                        # This nasty splatting is required because boto3 chokes on trying to set things like dependsOn to None if you
                        # have no dependencies, you have to not pass the parameter at all
                        response = batch_client.submit_job(**{k: v for k, v in {
                            'jobName': '{}_{}'.format(meta['ExecutionName'], resource['BatchJob']),
                            'jobQueue': os.environ['BATCH_JOB_QUEUE_ARN'],
                            'jobDefinition': os.environ['BATCH_JOB_DEFINITION_ARN'],
                            'parameters': {
                                "Job": resource['BatchJob'],
                                "Meta": json.dumps(meta, default=json_serial),
                                "Input": json.dumps(input_data, default=json_serial)
                            },
                            'arrayProperties': {'size': array_size} if array_size != 1 else None,
                            'containerOverrides': {
                                "environment": [
                                    {"name": "ENVIRONMENT", "value": os.environ['ENVIRONMENT']},
                                    {"name": "AWS_DEFAULT_REGION", "value": os.environ['AWS_DEFAULT_REGION']},
                                ],
                                "memory": resource.get('Memory', 256),
                                "vcpus": resource.get('Vcpus', 2),
                            }
                        }.items() if v is not None})
                        print(json.dumps(response))


                    def json_serial(obj):
                        from datetime import datetime
                        if isinstance(obj, datetime):
                            serial = obj.isoformat()
                            return serial
                        raise TypeError("Type not serializable")

            Environment:
                Variables:
                    ENVIRONMENT: { Ref: "Environment" }
                    STEP_FUNCTIONS_ACTIVITY_ARN: { Ref: "StepFunctionsActivity" }
                    STEP_FUNCTIONS_STATE_MACHINE_ARN: { Ref: "StateMachine" }
                    BATCH_JOB_QUEUE_ARN: { "Fn::Sub": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute" }
                    BATCH_JOB_DEFINITION_ARN: { Ref: "BatchJobDefinition" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "300"
            Role: { "Fn::GetAtt" : [ "StreamLambdaRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-cwetobatch" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-cwetobatch" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    CweToBatchTriggerRule:
        Type: "AWS::Events::Rule"
        Properties:
            Description: "Triggered Rule"
            EventPattern:
                source: [ "customaws.stepfunctions" ]
                resources: [ { Ref: "StepFunctionsActivity" } ]
            State: "ENABLED"
            Targets:
              - Arn: { "Fn::GetAtt": [ "CweToBatchLambda", "Arn" ] }
                Id: "TargetFunctionV1"

    CweToBatchInvokePermission:
        Type: "AWS::Lambda::Permission"
        Properties:
            FunctionName: { Ref: "CweToBatchLambda" }
            Action: "lambda:InvokeFunction"
            Principal: "events.amazonaws.com"
            SourceArn: { "Fn::GetAtt": [ "CweToBatchTriggerRule", "Arn" ] }

    BatchEventsLambda:
        Type: "AWS::Lambda::Function"
        Properties:
            Code:
                ZipFile: !Sub |
                    import boto3, datetime, json, os
                    from botocore.exceptions import ClientError

                    logs_client = boto3.client('logs')
                    sfn_client = boto3.client('stepfunctions')


                    def handler(event, _):
                        print(json.dumps(event))
                        meta = json.loads(event['detail']['parameters']['Meta'])

                        now = int(datetime.datetime.strptime(event['time'], "%Y-%m-%dT%H:%M:%SZ").timestamp())
                        execution_name = meta['ExecutionName']

                        if event['detail-type'] == "Batch Job State Change":
                            message = {
                                'job_name': event['detail']['jobName'].split('_', 1)[1],
                                'job_status': event['detail']['status'],
                                'job_id': event['detail']['jobId']
                            }

                            try:
                                log_stream = event['detail']['attempts'][-1]['container']['logStreamName']
                                message[
                                    'log_url'] = 'https://{region}.console.aws.amazon.com/cloudwatch/home?region={region}#logEventViewer:group={group};stream={stream}'.format(
                                    region=os.environ['AWS_DEFAULT_REGION'],
                                    group='/aws/batch/job',
                                    stream=log_stream,
                                )
                            except IndexError:
                                log_stream = None
                                pass

                            log(execution_name, json.dumps(message), now)

                            if 'TaskToken' in meta:
                                try:
                                    # Array jobs have a sixth colon, parent jobs only have five
                                    is_array_job = event['resources'][0].count(':') == 6
                                    if event['detail']['status'] == 'SUCCEEDED' and not is_array_job:
                                        print('Sending success')
                                        output = json.dumps({"Meta": meta, "Status": 'SUCCEEDED', "Output": {}})
                                        sfn_client.send_task_success(taskToken=meta['TaskToken'], output=output)
                                    # But for failures, send the signal straight away so we can link to the CloudWatch logs
                                    elif event['detail']['status'] == 'FAILED':
                                        print('sending failure')
                                        sfn_client.send_task_failure(taskToken=meta['TaskToken'], error='Job Error', cause=log_stream)
                                except ClientError as e:
                                    print(str(e))


                    def log(log_stream, message, now):
                        for i in range(10):
                            try:
                                res = logs_client.describe_log_streams(
                                    logGroupName='/biometrix/preprocessing/{ENVIRONMENT}'.format(**os.environ),
                                    logStreamNamePrefix=log_stream
                                )
                                print(res)
                                if len(res['logStreams']) == 0:
                                    print('No log stream')
                                    return

                                sequence_token = res['logStreams'][0]['uploadSequenceToken']
                                print(sequence_token)
                                logs_client.put_log_events(
                                    logGroupName='/biometrix/preprocessing/{ENVIRONMENT}'.format(**os.environ),
                                    logStreamName=log_stream,
                                    logEvents=[{'timestamp': now * 1000, 'message': message}],
                                    sequenceToken=sequence_token
                                )
                                return
                            except Exception as e:
                                print(str(e))
                                continue

            Environment:
                Variables:
                    ENVIRONMENT: { Ref: "Environment" }
                    STEP_FUNCTIONS_ACTIVITY_ARN: { Ref: "StepFunctionsActivity" }
                    STEP_FUNCTIONS_STATE_MACHINE_ARN: { Ref: "StateMachine" }
                    BATCH_JOB_QUEUE_ARN: { "Fn::Sub": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute" }
                    BATCH_JOB_DEFINITION_ARN: { Ref: "BatchJobDefinition" }
            Handler: "index.handler"
            Runtime: "python3.6"
            Timeout: "300"
            Role: { "Fn::GetAtt" : [ "StreamLambdaRole", "Arn" ] }
            FunctionName: { "Fn::Sub": "preprocessing-${Environment}-pipeline-batch-stream" }
            Tags:
              - { Key: "Name", Value: { "Fn::Sub": "preprocessing-${Environment}-pipeline-batch-stream" } }
              - { Key: "Management", Value: "managed" }
              - { Key: "Project", Value: "preprocessing" }
              - { Key: "Environment", Value: { Ref: "Environment" } }

    BatchEventsTriggerRule:
        Type: "AWS::Events::Rule"
        Properties:
            Description: "Triggered Rule"
            EventPattern:
                source: [ "aws.batch" ]
                detail:
                    jobQueue: [ { "Fn::Sub": "arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-queue/preprocessing-${Environment}-compute" } ]
            State: "ENABLED"
            Targets:
              - Arn: { "Fn::GetAtt": [ "BatchEventsLambda", "Arn" ] }
                Id: "TargetFunctionV1"

    BatchEventsInvokePermission:
        Type: "AWS::Lambda::Permission"
        Properties:
            FunctionName: { Ref: "BatchEventsLambda" }
            Action: "lambda:InvokeFunction"
            Principal: "events.amazonaws.com"
            SourceArn: { "Fn::GetAtt": [ "BatchEventsTriggerRule", "Arn" ] }

    StateMachine:
        Type: "AWS::StepFunctions::StateMachine"
        Properties:
            DefinitionString: !Sub |
                {
                    "StartAt": "Start",
                    "States": {
                        "Start": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "PassStatus0",
                                    "States": {
                                        "PassStatus0": {
                                            "Type": "Pass",
                                            "Result": "PROCESSING_IN_PROGRESS",
                                            "ResultPath": "$.SourceEvent.SessionStatus",
                                            "Next": "UpdateStatus0"
                                        },
                                        "UpdateStatus0": {
                                            "Type": "Task",
                                            "Resource": "${LambdaUpdateStatus.Arn}",
                                            "InputPath": "$.SourceEvent",
                                            "OutputPath": null,
                                            "ResultPath": null,
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildDownloadAndChunkContext",
                                    "States": {
                                        "BuildDownloadAndChunkContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareDownloadAndChunk.Arn}",
                                            "ResultPath": "$.DownloadAndChunk",
                                            "Next": "DownloadAndChunk"
                                        },
                                        "DownloadAndChunk": {
                                            "Type": "Task",
                                            "InputPath": "$.DownloadAndChunk",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.Output.DownloadAndChunk",
                                            "OutputPath": "$.Output",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "ReadData",
                                    "States": {
                                        "ReadData": {
                                            "Type": "Task",
                                            "Resource": "${LambdaReadData.Arn}",
                                            "ResultPath": "$.Output.ReadDatabase",
                                            "OutputPath": "$.Output",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [ "States.ALL" ],
                                    "Next": "ExceptionFailProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                }
                            ],
                            "ResultPath": "$._Unpack",
                            "Next": "UnpackParallelResults1"
                        },
                        "UnpackParallelResults1": {
                            "Type": "Task",
                            "Resource": "${LambdaUnpackParallelResults.Arn}",
                            "Next": "BuildTransformAndPlacementContext"
                        },
                        "BuildTransformAndPlacementContext": {
                            "Type": "Task",
                            "Resource": "${LambdaPrepareTransformAndPlacement.Arn}",
                            "ResultPath": "$.TransformAndPlacement",
                            "Next": "TransformAndPlacement"
                        },
                        "TransformAndPlacement": {
                            "Type": "Task",
                            "InputPath": "$.TransformAndPlacement",
                            "Resource": "${StepFunctionsActivity}",
                            "TimeoutSeconds": 600,
                            "HeartbeatSeconds": 600,
                            "Catch": [
                                {
                                    "ErrorEquals": [ "States.ALL" ],
                                    "Next": "ExceptionFailProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                }
                            ],
                            "ResultPath": "$.TransformAndPlacement",
                            "Next": "BuildSessionProcess2Context"
                        },
                        "BuildSessionProcess2Context": {
                            "Type": "Task",
                            "Resource": "${LambdaPrepareSessionProcess2.Arn}",
                            "ResultPath": "$.SessionProcess2",
                            "Next": "SessionProcess2"
                        },
                        "SessionProcess2": {
                            "Type": "Task",
                            "InputPath": "$.SessionProcess2",
                            "Resource": "${StepFunctionsActivity}",
                            "TimeoutSeconds": 600,
                            "HeartbeatSeconds": 600,
                            "Catch": [
                                {
                                    "ErrorEquals": [ "States.ALL" ],
                                    "Next": "ExceptionFailProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                }
                            ],
                            "ResultPath": "$.SessionProcess2",
                            "Next": "BuildScoringContext"
                        },
                        "BuildScoringContext": {
                            "Type": "Task",
                            "Resource": "${LambdaPrepareScoring.Arn}",
                            "ResultPath": "$.Scoring",
                            "Next": "Scoring"
                        },
                        "Scoring": {
                            "Type": "Task",
                            "InputPath": "$.Scoring",
                            "Resource": "${StepFunctionsActivity}",
                            "TimeoutSeconds": 600,
                            "HeartbeatSeconds": 600,
                            "Catch": [
                                {
                                    "ErrorEquals": [ "NoHistoricalDataException" ],
                                    "Next": "ExceptionSkipProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                },
                                {
                                    "ErrorEquals": [ "States.ALL" ],
                                    "Next": "ExceptionFailProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                }
                            ],
                            "ResultPath": "$.Scoring",
                            "Next": "Aggregate1"
                        },
                        "Aggregate1": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "BuildAggregateProgComp",
                                    "States": {
                                        "BuildAggregateProgComp": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateProgComp.Arn}",
                                            "ResultPath": "$.AggregateProgComp",
                                            "Next": "AggregateProgComp"
                                        },
                                        "AggregateProgComp": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateProgComp",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateProgComp",
                                            "Next": "BuildAggregateProgCompDate"
                                        },
                                        "BuildAggregateProgCompDate": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateProgCompDate.Arn}",
                                            "ResultPath": "$.AggregateProgCompDate",
                                            "Next": "AggregateProgCompDate"
                                        },
                                        "AggregateProgCompDate": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateProgCompDate",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateProgCompDate",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildAggregateSessionContext",
                                    "States": {
                                        "BuildAggregateSessionContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateSession.Arn}",
                                            "ResultPath": "$.AggregateSession",
                                            "Next": "AggregateSession"
                                        },
                                        "AggregateSession": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateSession",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateSession",
                                            "Next": "BuildAggregateDateUserContext"
                                        },
                                        "BuildAggregateDateUserContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateDateUser.Arn}",
                                            "ResultPath": "$.AggregateDateUser",
                                            "Next": "AggregateDateUser"
                                        },
                                        "AggregateDateUser": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateDateUser",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateDateUser",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildAggregateTwominContext",
                                    "States": {
                                        "BuildAggregateTwominContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateTwomin.Arn}",
                                            "ResultPath": "$.AggregateTwomin",
                                            "Next": "AggregateTwomin"
                                        },
                                        "AggregateTwomin": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateTwomin",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateTwomin",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildAggregateBlocksContext",
                                    "States": {
                                        "BuildAggregateBlocksContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateBlocks.Arn}",
                                            "ResultPath": "$.AggregateBlocks",
                                            "Next": "AggregateBlocks"
                                        },
                                        "AggregateBlocks": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateBlocks",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateBlocks",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [ "States.ALL" ],
                                    "Next": "ExceptionFailProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                }
                            ],
                            "ResultPath": null,
                            "Next": "Aggregate2"
                        },
                        "Aggregate2": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "BuildAggregateTeamContext",
                                    "States": {
                                        "BuildAggregateTeamContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateTeam.Arn}",
                                            "ResultPath": "$.AggregateTeam",
                                            "Next": "AggregateTeam"
                                        },
                                        "AggregateTeam": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateTeam",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateTeam",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "BuildAggregateTrainingGroupContext",
                                    "States": {
                                        "BuildAggregateTrainingGroupContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareAggregateTrainingGroup.Arn}",
                                            "ResultPath": "$.AggregateTrainingGroup",
                                            "Next": "AggregateTrainingGroup"
                                        },
                                        "AggregateTrainingGroup": {
                                            "Type": "Task",
                                            "InputPath": "$.AggregateTrainingGroup",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.AggregateTrainingGroup",
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "Catch": [
                                {
                                    "ErrorEquals": [ "States.ALL" ],
                                    "Next": "ExceptionFailProcessing",
                                    "ResultPath": "$._ExceptionOutput"
                                }
                            ],
                            "ResultPath": null,
                            "Next": "Post"
                        },
                        "Post": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "BuildCleanupContext",
                                    "States": {
                                        "BuildCleanupContext": {
                                            "Type": "Task",
                                            "Resource": "${LambdaPrepareCleanup.Arn}",
                                            "ResultPath": "$.Cleanup",
                                            "Next": "Cleanup"
                                        },
                                        "Cleanup": {
                                            "Type": "Task",
                                            "InputPath": "$.Cleanup",
                                            "Resource": "${StepFunctionsActivity}",
                                            "TimeoutSeconds": 600,
                                            "HeartbeatSeconds": 600,
                                            "ResultPath": "$.Cleanup",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "PassStatusComplete",
                                    "States": {
                                        "PassStatusComplete": {
                                            "Type": "Pass",
                                            "Result": "PROCESSING_COMPLETE",
                                            "ResultPath": "$.SourceEvent.SessionStatus",
                                            "Next": "MarkProcessingComplete"
                                        },
                                        "MarkProcessingComplete": {
                                            "Type": "Task",
                                            "Resource": "${LambdaUpdateStatus.Arn}",
                                            "InputPath": "$.SourceEvent",
                                            "OutputPath": null,
                                            "ResultPath": null,
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": "$.Cleanup",
                            "End": true
                        },
                        "ExceptionSkipProcessing": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "NotifyFailure0",
                                    "States": {
                                        "NotifyFailure0": {
                                            "Type": "Task",
                                            "Resource": "${LambdaNotifyFailure.Arn}",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "PassStatus1",
                                    "States": {
                                        "PassStatus1": {
                                            "Type": "Pass",
                                            "Result": "PROCESSING_SKIPPED",
                                            "ResultPath": "$.SourceEvent.SessionStatus",
                                            "Next": "UpdateStatus1"
                                        },
                                        "UpdateStatus1": {
                                            "Type": "Task",
                                            "Resource": "${LambdaUpdateStatus.Arn}",
                                            "InputPath": "$.SourceEvent",
                                            "OutputPath": null,
                                            "ResultPath": null,
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": null,
                            "Next": "ExceptionStop"
                        },
                        "ExceptionFailProcessing": {
                            "Type": "Parallel",
                            "Branches": [
                                {
                                    "StartAt": "NotifyFailure1",
                                    "States": {
                                        "NotifyFailure1": {
                                            "Type": "Task",
                                            "Resource": "${LambdaNotifyFailure.Arn}",
                                            "End": true
                                        }
                                    }
                                },
                                {
                                    "StartAt": "PassStatus2",
                                    "States": {
                                        "PassStatus2": {
                                            "Type": "Pass",
                                            "Result": "PROCESSING_FAILED",
                                            "ResultPath": "$.SourceEvent.SessionStatus",
                                            "Next": "UpdateStatus2"
                                        },
                                        "UpdateStatus2": {
                                            "Type": "Task",
                                            "Resource": "${LambdaUpdateStatus.Arn}",
                                            "InputPath": "$.SourceEvent",
                                            "OutputPath": null,
                                            "ResultPath": null,
                                            "End": true
                                        }
                                    }
                                }
                            ],
                            "ResultPath": null,
                            "Next": "ExceptionStop"
                        },
                        "ExceptionStop": {
                            "Type": "Fail"
                        }
                    }
                }

            RoleArn: { "Fn::ImportValue" : "StepFunctionsServiceRole" }
            StateMachineName: { "Fn::Sub": "preprocessing-${Environment}" }

Outputs:
    ActivityArn:
        Description: "The ARN of the Batch Activity"
        Value: { Ref: "StepFunctionsActivity" }
    StateMachineArn:
        Description: "The ARN of the SFN state machine"
        Value: { Ref: "StateMachine" }
